// Warning!  This file was generated by running a program (see project |tools|).
// If you change it, the changes will be lost the next time the generator is
// run.  You should change the generator instead.

namespace {

NavigationFrameParameters DeserializeNavigationFrameParameters(serialization::NavigationFrameParameters const& navigation_frame_parameters) {
  return {navigation_frame_parameters.extension(),
          navigation_frame_parameters.centre_index(),
          navigation_frame_parameters.primary_index(),
          navigation_frame_parameters.secondary_index()};
}

XYZ DeserializeXYZ(serialization::XYZ const& xyz) {
  return {xyz.x(),
          xyz.y(),
          xyz.z()};
}

Burn DeserializeBurn(serialization::Burn const& burn) {
  return {burn.thrust_in_kilonewtons(),
          burn.specific_impulse_in_seconds_g0(),
          DeserializeNavigationFrameParameters(burn.frame()),
          burn.initial_time(),
          DeserializeXYZ(burn.delta_v())};
}

NavigationManoeuvre DeserializeNavigationManoeuvre(serialization::NavigationManoeuvre const& navigation_manoeuvre) {
  return {DeserializeBurn(navigation_manoeuvre.burn()),
          navigation_manoeuvre.initial_mass_in_tonnes(),
          navigation_manoeuvre.final_mass_in_tonnes(),
          navigation_manoeuvre.mass_flow(),
          navigation_manoeuvre.duration(),
          navigation_manoeuvre.final_time(),
          navigation_manoeuvre.time_of_half_delta_v(),
          navigation_manoeuvre.time_to_half_delta_v(),
          DeserializeXYZ(navigation_manoeuvre.direction())};
}

KSPPart DeserializeKSPPart(serialization::KSPPart const& ksp_part) {
  return {DeserializeXYZ(ksp_part.world_position()),
          DeserializeXYZ(ksp_part.world_velocity()),
          ksp_part.mass_in_tonnes(),
          DeserializeXYZ(ksp_part.gravitational_acceleration_to_be_applied_by_ksp()),
          ksp_part.id()};
}

QP DeserializeQP(serialization::QP const& qp) {
  return {DeserializeXYZ(qp.q()),
          DeserializeXYZ(qp.p())};
}

WXYZ DeserializeWXYZ(serialization::WXYZ const& wxyz) {
  return {wxyz.w(),
          wxyz.x(),
          wxyz.y(),
          wxyz.z()};
}

XYZSegment DeserializeXYZSegment(serialization::XYZSegment const& xyz_segment) {
  return {DeserializeXYZ(xyz_segment.begin()),
          DeserializeXYZ(xyz_segment.end())};
}

serialization::NavigationFrameParameters SerializeNavigationFrameParameters(NavigationFrameParameters const& navigation_frame_parameters) {
  serialization::NavigationFrameParameters m;
  m.set_extension(navigation_frame_parameters.extension);
  m.set_centre_index(navigation_frame_parameters.centre_index);
  m.set_primary_index(navigation_frame_parameters.primary_index);
  m.set_secondary_index(navigation_frame_parameters.secondary_index);
  return m;
}

serialization::XYZ SerializeXYZ(XYZ const& xyz) {
  serialization::XYZ m;
  m.set_x(xyz.x);
  m.set_y(xyz.y);
  m.set_z(xyz.z);
  return m;
}

serialization::Burn SerializeBurn(Burn const& burn) {
  serialization::Burn m;
  m.set_thrust_in_kilonewtons(burn.thrust_in_kilonewtons);
  m.set_specific_impulse_in_seconds_g0(burn.specific_impulse_in_seconds_g0);
  *m.mutable_frame() = SerializeNavigationFrameParameters(burn.frame);
  m.set_initial_time(burn.initial_time);
  *m.mutable_delta_v() = SerializeXYZ(burn.delta_v);
  return m;
}

serialization::NavigationManoeuvre SerializeNavigationManoeuvre(NavigationManoeuvre const& navigation_manoeuvre) {
  serialization::NavigationManoeuvre m;
  *m.mutable_burn() = SerializeBurn(navigation_manoeuvre.burn);
  m.set_initial_mass_in_tonnes(navigation_manoeuvre.initial_mass_in_tonnes);
  m.set_final_mass_in_tonnes(navigation_manoeuvre.final_mass_in_tonnes);
  m.set_mass_flow(navigation_manoeuvre.mass_flow);
  m.set_duration(navigation_manoeuvre.duration);
  m.set_final_time(navigation_manoeuvre.final_time);
  m.set_time_of_half_delta_v(navigation_manoeuvre.time_of_half_delta_v);
  m.set_time_to_half_delta_v(navigation_manoeuvre.time_to_half_delta_v);
  *m.mutable_direction() = SerializeXYZ(navigation_manoeuvre.direction);
  return m;
}

serialization::KSPPart SerializeKSPPart(KSPPart const& ksp_part) {
  serialization::KSPPart m;
  *m.mutable_world_position() = SerializeXYZ(ksp_part.world_position);
  *m.mutable_world_velocity() = SerializeXYZ(ksp_part.world_velocity);
  m.set_mass_in_tonnes(ksp_part.mass_in_tonnes);
  *m.mutable_gravitational_acceleration_to_be_applied_by_ksp() = SerializeXYZ(ksp_part.gravitational_acceleration_to_be_applied_by_ksp);
  m.set_id(ksp_part.id);
  return m;
}

serialization::QP SerializeQP(QP const& qp) {
  serialization::QP m;
  *m.mutable_q() = SerializeXYZ(qp.q);
  *m.mutable_p() = SerializeXYZ(qp.p);
  return m;
}

serialization::WXYZ SerializeWXYZ(WXYZ const& wxyz) {
  serialization::WXYZ m;
  m.set_w(wxyz.w);
  m.set_x(wxyz.x);
  m.set_y(wxyz.y);
  m.set_z(wxyz.z);
  return m;
}

serialization::XYZSegment SerializeXYZSegment(XYZSegment const& xyz_segment) {
  serialization::XYZSegment m;
  *m.mutable_begin() = SerializeXYZ(xyz_segment.begin);
  *m.mutable_end() = SerializeXYZ(xyz_segment.end);
  return m;
}

}  // namespace

void AddVesselToNextPhysicsBubble::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  for (KSPPart const* parts = in.parts; parts < in.parts + in.count; ++parts) {
    *m->add_parts() = SerializeKSPPart(*parts);
  }
}

void AddVesselToNextPhysicsBubble::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto parts = [](::google::protobuf::RepeatedPtrField<serialization::KSPPart> const& messages) -> std::vector<KSPPart> {
      std::vector<KSPPart> deserialized_parts;
      for (auto const& message : messages) {
        deserialized_parts.push_back(DeserializeKSPPart(message));
      }
      return deserialized_parts;
    }(in.parts());
  interface::principia__AddVesselToNextPhysicsBubble(plugin, vessel_guid, &parts[0], parts.size());
}

void AdvanceTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
  m->set_planetarium_rotation(in.planetarium_rotation);
}

void AdvanceTime::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto t = in.t();
  auto planetarium_rotation = in.planetarium_rotation();
  interface::principia__AdvanceTime(plugin, t, planetarium_rotation);
}

void AtEnd::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_line_and_iterator(SerializePointer(in.line_and_iterator));
}

void AtEnd::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void AtEnd::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto line_and_iterator = DeserializePointer<LineAndIterator const*>(*pointer_map, in.line_and_iterator());
  auto const result = interface::principia__AtEnd(line_and_iterator);
  CHECK(message.return_().result() == result);
}

void BubbleDisplacementCorrection::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_position() = SerializeXYZ(in.sun_position);
}

void BubbleDisplacementCorrection::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void BubbleDisplacementCorrection::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto sun_position = DeserializeXYZ(in.sun_position());
  auto const result = interface::principia__BubbleDisplacementCorrection(plugin, sun_position);
  CHECK(DeserializeXYZ(message.return_().result()) == result);
}

void BubbleVelocityCorrection::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_reference_body_index(in.reference_body_index);
}

void BubbleVelocityCorrection::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void BubbleVelocityCorrection::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto reference_body_index = in.reference_body_index();
  auto const result = interface::principia__BubbleVelocityCorrection(plugin, reference_body_index);
  CHECK(DeserializeXYZ(message.return_().result()) == result);
}

void CelestialFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
}

void CelestialFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void CelestialFromParent::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto const result = interface::principia__CelestialFromParent(plugin, celestial_index);
  CHECK(DeserializeQP(message.return_().result()) == result);
}

void CurrentTime::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void CurrentTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void CurrentTime::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto const result = interface::principia__CurrentTime(plugin);
  CHECK(message.return_().result() == result);
}

void DeleteLineAndIterator::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_line_and_iterator(SerializePointer(*in.line_and_iterator));
}

void DeleteLineAndIterator::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_line_and_iterator(SerializePointer(*out.line_and_iterator));
}

void DeleteLineAndIterator::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto line_and_iterator = DeserializePointer<LineAndIterator*>(*pointer_map, in.line_and_iterator());
  interface::principia__DeleteLineAndIterator(&line_and_iterator);
  Delete(pointer_map, in.line_and_iterator());
}

void DeletePlugin::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(*in.plugin));
}

void DeletePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_plugin(SerializePointer(*out.plugin));
}

void DeletePlugin::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  interface::principia__DeletePlugin(&plugin);
  Delete(pointer_map, in.plugin());
}

void DeletePluginSerialization::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_serialization(SerializePointer(*in.serialization));
}

void DeletePluginSerialization::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_serialization(SerializePointer(*out.serialization));
}

void DeletePluginSerialization::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto serialization = DeserializePointer<char const*>(*pointer_map, in.serialization());
  interface::principia__DeletePluginSerialization(&serialization);
  Delete(pointer_map, in.serialization());
}

void DeserializePlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_serialization(std::string(in.serialization, in.serialization_size));
  m->set_deserializer(SerializePointer(*in.deserializer));
  m->set_plugin(SerializePointer(*in.plugin));
}

void DeserializePlugin::Fill(Out const& out, not_null<Message*> const message) {
  auto* const m = message->mutable_out();
  m->set_deserializer(SerializePointer(*out.deserializer));
  m->set_plugin(SerializePointer(*out.plugin));
}

void DeserializePlugin::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto serialization = &in.serialization();
  auto deserializer = DeserializePointer<PushDeserializer*>(*pointer_map, in.deserializer());
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  interface::principia__DeserializePlugin(serialization->c_str(), serialization->size(), &deserializer, &plugin);
  if (serialization->empty()) {
    Delete(pointer_map, in.deserializer());
  }
  if (!serialization->empty()) {
    Insert(pointer_map, message.out().deserializer(), deserializer);
  }
  Insert(pointer_map, message.out().plugin(), plugin);
}

void DirectlyInsertCelestial::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  if (in.parent_index != nullptr) {
    m->set_parent_index(*in.parent_index);
  }
  m->set_gravitational_parameter(in.gravitational_parameter);
  if (in.axis_right_ascension != nullptr) {
    m->set_axis_right_ascension(in.axis_right_ascension);
  }
  if (in.axis_declination != nullptr) {
    m->set_axis_declination(in.axis_declination);
  }
  if (in.j2 != nullptr) {
    m->set_j2(in.j2);
  }
  if (in.reference_radius != nullptr) {
    m->set_reference_radius(in.reference_radius);
  }
  m->set_x(in.x);
  m->set_y(in.y);
  m->set_z(in.z);
  m->set_vx(in.vx);
  m->set_vy(in.vy);
  m->set_vz(in.vz);
}

void DirectlyInsertCelestial::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.has_parent_index() ? std::make_unique<int const>(in.parent_index()) : nullptr;
  auto gravitational_parameter = in.gravitational_parameter().c_str();
  auto axis_right_ascension = in.has_axis_right_ascension() ? in.axis_right_ascension().c_str() : nullptr;
  auto axis_declination = in.has_axis_declination() ? in.axis_declination().c_str() : nullptr;
  auto j2 = in.has_j2() ? in.j2().c_str() : nullptr;
  auto reference_radius = in.has_reference_radius() ? in.reference_radius().c_str() : nullptr;
  auto x = in.x().c_str();
  auto y = in.y().c_str();
  auto z = in.z().c_str();
  auto vx = in.vx().c_str();
  auto vy = in.vy().c_str();
  auto vz = in.vz().c_str();
  interface::principia__DirectlyInsertCelestial(plugin, celestial_index, parent_index.get(), gravitational_parameter, axis_right_ascension, axis_declination, j2, reference_radius, x, y, z, vx, vy, vz);
}

void EndInitialization::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void EndInitialization::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  interface::principia__EndInitialization(plugin);
}

void FetchAndIncrement::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_line_and_iterator(SerializePointer(in.line_and_iterator));
}

void FetchAndIncrement::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZSegment(result);
}

void FetchAndIncrement::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto line_and_iterator = DeserializePointer<LineAndIterator*>(*pointer_map, in.line_and_iterator());
  auto const result = interface::principia__FetchAndIncrement(line_and_iterator);
  CHECK(DeserializeXYZSegment(message.return_().result()) == result);
}

void FlightPlanAppend::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
}

void FlightPlanAppend::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanAppend::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn());
  auto const result = interface::principia__FlightPlanAppend(plugin, vessel_guid, burn);
  CHECK(message.return_().result() == result);
}

void FlightPlanCreate::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
  m->set_mass_in_tonnes(in.mass_in_tonnes);
}

void FlightPlanCreate::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto mass_in_tonnes = in.mass_in_tonnes();
  interface::principia__FlightPlanCreate(plugin, vessel_guid, final_time, mass_in_tonnes);
}

void FlightPlanDelete::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanDelete::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanDelete(plugin, vessel_guid);
}

void FlightPlanExists::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanExists::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanExists::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanExists(plugin, vessel_guid);
  CHECK(message.return_().result() == result);
}

void FlightPlanGetManoeuvre::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_index(in.index);
}

void FlightPlanGetManoeuvre::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationManoeuvre(result);
}

void FlightPlanGetManoeuvre::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto index = in.index();
  auto const result = interface::principia__FlightPlanGetManoeuvre(plugin, vessel_guid, index);
  CHECK(DeserializeNavigationManoeuvre(message.return_().result()) == result);
}

void FlightPlanNumberOfManoeuvres::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfManoeuvres::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfManoeuvres::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfManoeuvres(plugin, vessel_guid);
  CHECK(message.return_().result() == result);
}

void FlightPlanNumberOfSegments::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanNumberOfSegments::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanNumberOfSegments::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__FlightPlanNumberOfSegments(plugin, vessel_guid);
  CHECK(message.return_().result() == result);
}

void FlightPlanRemoveLast::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void FlightPlanRemoveLast::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__FlightPlanRemoveLast(plugin, vessel_guid);
}

void FlightPlanRenderedSegment::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  m->set_index(in.index);
}

void FlightPlanRenderedSegment::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void FlightPlanRenderedSegment::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto index = in.index();
  auto const result = interface::principia__FlightPlanRenderedSegment(plugin, vessel_guid, sun_world_position, index);
  Insert(pointer_map, message.return_().result(), result);
}

void FlightPlanReplaceLast::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_burn() = SerializeBurn(in.burn);
}

void FlightPlanReplaceLast::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanReplaceLast::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto burn = DeserializeBurn(in.burn());
  auto const result = interface::principia__FlightPlanReplaceLast(plugin, vessel_guid, burn);
  CHECK(message.return_().result() == result);
}

void FlightPlanSetFinalTime::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_final_time(in.final_time);
}

void FlightPlanSetFinalTime::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void FlightPlanSetFinalTime::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto final_time = in.final_time();
  auto const result = interface::principia__FlightPlanSetFinalTime(plugin, vessel_guid, final_time);
  CHECK(message.return_().result() == result);
}

void FlightPlanSetTolerances::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_length_integration_tolerance(in.length_integration_tolerance);
  m->set_speed_integration_tolerance(in.speed_integration_tolerance);
}

void FlightPlanSetTolerances::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto length_integration_tolerance = in.length_integration_tolerance();
  auto speed_integration_tolerance = in.speed_integration_tolerance();
  interface::principia__FlightPlanSetTolerances(plugin, vessel_guid, length_integration_tolerance, speed_integration_tolerance);
}

void ForgetAllHistoriesBefore::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
}

void ForgetAllHistoriesBefore::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto t = in.t();
  interface::principia__ForgetAllHistoriesBefore(plugin, t);
}

void GetBufferDuration::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferDuration::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const result = interface::principia__GetBufferDuration();
  CHECK(message.return_().result() == result);
}

void GetBufferedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetBufferedLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const result = interface::principia__GetBufferedLogging();
  CHECK(message.return_().result() == result);
}

void GetNavigationFrameParameters::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_navigation_frame(SerializePointer(in.navigation_frame));
}

void GetNavigationFrameParameters::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeNavigationFrameParameters(result);
}

void GetNavigationFrameParameters::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto navigation_frame = DeserializePointer<NavigationFrame const*>(*pointer_map, in.navigation_frame());
  auto const result = interface::principia__GetNavigationFrameParameters(navigation_frame);
  Delete(pointer_map, in.navigation_frame());
  CHECK(DeserializeNavigationFrameParameters(message.return_().result()) == result);
}

void GetPlottingFrame::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void GetPlottingFrame::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void GetPlottingFrame::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto const result = interface::principia__GetPlottingFrame(plugin);
  Insert(pointer_map, message.return_().result(), result);
}

void GetStderrLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetStderrLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const result = interface::principia__GetStderrLogging();
  CHECK(message.return_().result() == result);
}

void GetSuppressedLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetSuppressedLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const result = interface::principia__GetSuppressedLogging();
  CHECK(message.return_().result() == result);
}

void GetVerboseLogging::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void GetVerboseLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const result = interface::principia__GetVerboseLogging();
  CHECK(message.return_().result() == result);
}

void HasPrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void HasPrediction::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasPrediction::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__HasPrediction(plugin, vessel_guid);
  CHECK(message.return_().result() == result);
}

void HasVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void HasVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void HasVessel::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__HasVessel(plugin, vessel_guid);
  CHECK(message.return_().result() == result);
}

void InitGoogleLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  interface::principia__InitGoogleLogging();
}

void InsertCelestial::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_gravitational_parameter(in.gravitational_parameter);
  m->set_parent_index(in.parent_index);
  *m->mutable_from_parent() = SerializeQP(in.from_parent);
}

void InsertCelestial::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto gravitational_parameter = in.gravitational_parameter();
  auto parent_index = in.parent_index();
  auto from_parent = DeserializeQP(in.from_parent());
  interface::principia__InsertCelestial(plugin, celestial_index, gravitational_parameter, parent_index, from_parent);
}

void InsertOrKeepVessel::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  m->set_parent_index(in.parent_index);
}

void InsertOrKeepVessel::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void InsertOrKeepVessel::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto parent_index = in.parent_index();
  auto const result = interface::principia__InsertOrKeepVessel(plugin, vessel_guid, parent_index);
  CHECK(message.return_().result() == result);
}

void InsertSun::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_gravitational_parameter(in.gravitational_parameter);
}

void InsertSun::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto gravitational_parameter = in.gravitational_parameter();
  interface::principia__InsertSun(plugin, celestial_index, gravitational_parameter);
}

void LogError::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogError::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogError(text);
}

void LogFatal::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogFatal::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogFatal(text);
}

void LogInfo::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogInfo::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogInfo(text);
}

void LogWarning::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_text(in.text);
}

void LogWarning::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto text = in.text().c_str();
  interface::principia__LogWarning(text);
}

void NavballOrientation::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
  *m->mutable_ship_world_position() = SerializeXYZ(in.ship_world_position);
}

void NavballOrientation::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeWXYZ(result);
}

void NavballOrientation::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto ship_world_position = DeserializeXYZ(in.ship_world_position());
  auto const result = interface::principia__NavballOrientation(plugin, sun_world_position, ship_world_position);
  CHECK(DeserializeWXYZ(message.return_().result()) == result);
}

void NewBarycentricRotatingNavigationFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_primary_index(in.primary_index);
  m->set_secondary_index(in.secondary_index);
}

void NewBarycentricRotatingNavigationFrame::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewBarycentricRotatingNavigationFrame::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto primary_index = in.primary_index();
  auto secondary_index = in.secondary_index();
  auto const result = interface::principia__NewBarycentricRotatingNavigationFrame(plugin, primary_index, secondary_index);
  Insert(pointer_map, message.return_().result(), result);
}

void NewBodyCentredNonRotatingNavigationFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_reference_body_index(in.reference_body_index);
}

void NewBodyCentredNonRotatingNavigationFrame::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewBodyCentredNonRotatingNavigationFrame::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto reference_body_index = in.reference_body_index();
  auto const result = interface::principia__NewBodyCentredNonRotatingNavigationFrame(plugin, reference_body_index);
  Insert(pointer_map, message.return_().result(), result);
}

void NewNavigationFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  *m->mutable_parameters() = SerializeNavigationFrameParameters(in.parameters);
}

void NewNavigationFrame::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewNavigationFrame::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto parameters = DeserializeNavigationFrameParameters(in.parameters());
  auto const result = interface::principia__NewNavigationFrame(plugin, parameters);
  Insert(pointer_map, message.return_().result(), result);
}

void NewPlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_initial_time(in.initial_time);
  m->set_planetarium_rotation_in_degrees(in.planetarium_rotation_in_degrees);
}

void NewPlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void NewPlugin::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto initial_time = in.initial_time();
  auto planetarium_rotation_in_degrees = in.planetarium_rotation_in_degrees();
  auto const result = interface::principia__NewPlugin(initial_time, planetarium_rotation_in_degrees);
  Insert(pointer_map, message.return_().result(), result);
}

void NumberOfSegments::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_line_and_iterator(SerializePointer(in.line_and_iterator));
}

void NumberOfSegments::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void NumberOfSegments::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto line_and_iterator = DeserializePointer<LineAndIterator const*>(*pointer_map, in.line_and_iterator());
  auto const result = interface::principia__NumberOfSegments(line_and_iterator);
  CHECK(message.return_().result() == result);
}

void PhysicsBubbleIsEmpty::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_plugin(SerializePointer(in.plugin));
}

void PhysicsBubbleIsEmpty::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(result);
}

void PhysicsBubbleIsEmpty::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto const result = interface::principia__PhysicsBubbleIsEmpty(plugin);
  CHECK(message.return_().result() == result);
}

void RenderedPrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void RenderedPrediction::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void RenderedPrediction::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const result = interface::principia__RenderedPrediction(plugin, vessel_guid, sun_world_position);
  Insert(pointer_map, message.return_().result(), result);
}

void RenderedVesselTrajectory::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_sun_world_position() = SerializeXYZ(in.sun_world_position);
}

void RenderedVesselTrajectory::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void RenderedVesselTrajectory::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto sun_world_position = DeserializeXYZ(in.sun_world_position());
  auto const result = interface::principia__RenderedVesselTrajectory(plugin, vessel_guid, sun_world_position);
  Insert(pointer_map, message.return_().result(), result);
}

void SayHello::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void SayHello::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const result = interface::principia__SayHello();
  Insert(pointer_map, message.return_().result(), result);
}

void SerializePlugin::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_serializer(SerializePointer(*in.serializer));
}

void SerializePlugin::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_serializer(SerializePointer(*out.serializer));
}

void SerializePlugin::Fill(Return const& result, not_null<Message*> const message) {
  message->mutable_return_()->set_result(SerializePointer(result));
}

void SerializePlugin::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto serializer = DeserializePointer<PullSerializer*>(*pointer_map, in.serializer());
  auto const result = interface::principia__SerializePlugin(plugin, &serializer);
  if (result == nullptr) {
    Delete(pointer_map, in.serializer());
  }
  if (result != nullptr) {
    Insert(pointer_map, message.out().serializer(), serializer);
  }
  if (result != nullptr) {
    Insert(pointer_map, message.return_().result(), result);
  }
}

void SetBufferDuration::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_seconds(in.seconds);
}

void SetBufferDuration::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto seconds = in.seconds();
  interface::principia__SetBufferDuration(seconds);
}

void SetBufferedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_max_severity(in.max_severity);
}

void SetBufferedLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto max_severity = in.max_severity();
  interface::principia__SetBufferedLogging(max_severity);
}

void SetPlottingFrame::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_navigation_frame(SerializePointer(*in.navigation_frame));
}

void SetPlottingFrame::Fill(Out const& out, not_null<Message*> const message) {
  message->mutable_out()->set_navigation_frame(SerializePointer(*out.navigation_frame));
}

void SetPlottingFrame::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto navigation_frame = DeserializePointer<NavigationFrame*>(*pointer_map, in.navigation_frame());
  interface::principia__SetPlottingFrame(plugin, &navigation_frame);
  Delete(pointer_map, in.navigation_frame());
}

void SetPredictionLength::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_t(in.t);
}

void SetPredictionLength::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto t = in.t();
  interface::principia__SetPredictionLength(plugin, t);
}

void SetPredictionLengthTolerance::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_l(in.l);
}

void SetPredictionLengthTolerance::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto l = in.l();
  interface::principia__SetPredictionLengthTolerance(plugin, l);
}

void SetPredictionSpeedTolerance::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_v(in.v);
}

void SetPredictionSpeedTolerance::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto v = in.v();
  interface::principia__SetPredictionSpeedTolerance(plugin, v);
}

void SetStderrLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetStderrLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetStderrLogging(min_severity);
}

void SetSuppressedLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_min_severity(in.min_severity);
}

void SetSuppressedLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto min_severity = in.min_severity();
  interface::principia__SetSuppressedLogging(min_severity);
}

void SetVerboseLogging::Fill(In const& in, not_null<Message*> const message) {
  message->mutable_in()->set_level(in.level);
}

void SetVerboseLogging::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto level = in.level();
  interface::principia__SetVerboseLogging(level);
}

void SetVesselStateOffset::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
  *m->mutable_from_parent() = SerializeQP(in.from_parent);
}

void SetVesselStateOffset::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto from_parent = DeserializeQP(in.from_parent());
  interface::principia__SetVesselStateOffset(plugin, vessel_guid, from_parent);
}

void UpdateCelestialHierarchy::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_celestial_index(in.celestial_index);
  m->set_parent_index(in.parent_index);
}

void UpdateCelestialHierarchy::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto celestial_index = in.celestial_index();
  auto parent_index = in.parent_index();
  interface::principia__UpdateCelestialHierarchy(plugin, celestial_index, parent_index);
}

void UpdatePrediction::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void UpdatePrediction::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  interface::principia__UpdatePrediction(plugin, vessel_guid);
}

void VesselBinormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselBinormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselBinormal::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselBinormal(plugin, vessel_guid);
  CHECK(DeserializeXYZ(message.return_().result()) == result);
}

void VesselFromParent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselFromParent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeQP(result);
}

void VesselFromParent::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselFromParent(plugin, vessel_guid);
  CHECK(DeserializeQP(message.return_().result()) == result);
}

void VesselNormal::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselNormal::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselNormal::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselNormal(plugin, vessel_guid);
  CHECK(DeserializeXYZ(message.return_().result()) == result);
}

void VesselTangent::Fill(In const& in, not_null<Message*> const message) {
  auto* const m = message->mutable_in();
  m->set_plugin(SerializePointer(in.plugin));
  m->set_vessel_guid(in.vessel_guid);
}

void VesselTangent::Fill(Return const& result, not_null<Message*> const message) {
  *message->mutable_return_()->mutable_result() = SerializeXYZ(result);
}

void VesselTangent::Run(Message const& message, not_null<Player::PointerMap*> const pointer_map) {
  auto const& in = message.in();
  auto plugin = DeserializePointer<Plugin const*>(*pointer_map, in.plugin());
  auto vessel_guid = in.vessel_guid().c_str();
  auto const result = interface::principia__VesselTangent(plugin, vessel_guid);
  CHECK(DeserializeXYZ(message.return_().result()) == result);
}

