From 0aebf498fdc5c2b504f14dfabfcc16d6684ccdc1 Mon Sep 17 00:00:00 2001
From: pleroy <phl+personal@google.com>
Date: Sun, 19 Oct 2014 00:43:06 +0200
Subject: [PATCH] Minimal closure of stack_trace_win.cc

---
 base/debug/stack_trace.h              |   1 +
 base/debug/stack_trace_win.cc         |  16 +-
 base/files/file_path.cc               |  67 +-------
 base/files/file_path.h                |  48 ------
 base/memory/singleton.h               |  11 --
 base/process/launch.h                 | 240 -----------------------------
 base/process/launch_win.cc            | 281 ----------------------------------
 base/strings/string_piece.h           |   1 -
 base/strings/string_util.cc           | 254 +-----------------------------
 base/strings/string_util.h            |  29 ----
 base/strings/string_util_win.h        |   2 +-
 base/synchronization/lock.cc          |  23 +--
 base/threading/platform_thread.h      |  77 ----------
 base/threading/platform_thread_win.cc | 236 ----------------------------
 14 files changed, 20 insertions(+), 1266 deletions(-)

diff --git a/base/debug/stack_trace.h b/base/debug/stack_trace.h
index 572f285..365e1d5 100644
--- a/base/debug/stack_trace.h
+++ b/base/debug/stack_trace.h
@@ -43,6 +43,7 @@ class BASE_EXPORT StackTrace {
  public:
   // Creates a stacktrace from the current location.
   StackTrace();
+  explicit StackTrace(int frames_to_skip);
 
   // Creates a stacktrace from an existing array of instruction
   // pointers (such as returned by Addresses()).  |count| will be
diff --git a/base/debug/stack_trace_win.cc b/base/debug/stack_trace_win.cc
index 8df6fc6..cd46248 100644
--- a/base/debug/stack_trace_win.cc
+++ b/base/debug/stack_trace_win.cc
@@ -10,12 +10,12 @@
 #include <iostream>
 
 #include "base/basictypes.h"
-#include "base/logging.h"
+#include "base/files/file_path.h"
+#include "base/memory/scoped_ptr.h"
 #include "base/memory/singleton.h"
 #include "base/process/launch.h"
-#include "base/strings/string_util.h"
 #include "base/synchronization/lock.h"
-#include "base/win/windows_version.h"
+#include "glog/logging.h"
 
 namespace base {
 namespace debug {
@@ -152,10 +152,6 @@ class SymbolContext {
 
     init_error_ = ERROR_SUCCESS;
 
-    // Work around a mysterious hang on Windows XP.
-    if (base::win::GetVersion() < base::win::VERSION_VISTA)
-      return;
-
     // When transferring the binaries e.g. between bots, path put
     // into the executable will get off. To still retrieve symbols correctly,
     // add the directory of the executable to symbol search path.
@@ -209,6 +205,12 @@ StackTrace::StackTrace() {
   count_ = CaptureStackBackTrace(0, arraysize(trace_), trace_, NULL);
 }
 
+StackTrace::StackTrace(int frames_to_skip) {
+  // When walking our own stack, use CaptureStackBackTrace().
+  count_ = CaptureStackBackTrace(
+      frames_to_skip, arraysize(trace_), trace_, NULL);
+}
+
 #if defined(COMPILER_MSVC)
 #pragma optimize("", on)
 #endif
diff --git a/base/files/file_path.cc b/base/files/file_path.cc
index 11bf69d..f317a5d 100644
--- a/base/files/file_path.cc
+++ b/base/files/file_path.cc
@@ -8,15 +8,13 @@
 #include <algorithm>
 
 #include "base/basictypes.h"
-#include "base/logging.h"
-#include "base/pickle.h"
 
 // These includes are just for the *Hack functions, and should be removed
 // when those functions are removed.
 #include "base/strings/string_piece.h"
 #include "base/strings/string_util.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/strings/utf_string_conversions.h"
+
+#include "glog/logging.h"
 
 #if defined(OS_MACOSX)
 #include "base/mac/scoped_cftyperef.h"
@@ -418,16 +416,6 @@ FilePath FilePath::InsertBeforeExtension(const StringType& suffix) const {
   return FilePath(ret);
 }
 
-FilePath FilePath::InsertBeforeExtensionASCII(const StringPiece& suffix)
-    const {
-  DCHECK(IsStringASCII(suffix));
-#if defined(OS_WIN)
-  return InsertBeforeExtension(ASCIIToUTF16(suffix.as_string()));
-#elif defined(OS_POSIX)
-  return InsertBeforeExtension(suffix.as_string());
-#endif
-}
-
 FilePath FilePath::AddExtension(const StringType& extension) const {
   if (IsEmptyOrSpecialCase(BaseName().value()))
     return FilePath();
@@ -520,15 +508,6 @@ FilePath FilePath::Append(const FilePath& component) const {
   return Append(component.value());
 }
 
-FilePath FilePath::AppendASCII(const StringPiece& component) const {
-  DCHECK(base::IsStringASCII(component));
-#if defined(OS_WIN)
-  return Append(ASCIIToUTF16(component.as_string()));
-#elif defined(OS_POSIX)
-  return Append(component.as_string());
-#endif
-}
-
 bool FilePath::IsAbsolute() const {
   return IsPathAbsolute(path_);
 }
@@ -631,54 +610,16 @@ string16 FilePath::LossyDisplayName() const {
   return path_;
 }
 
-std::string FilePath::MaybeAsASCII() const {
-  if (base::IsStringASCII(path_))
-    return UTF16ToASCII(path_);
-  return std::string();
-}
-
-std::string FilePath::AsUTF8Unsafe() const {
-  return WideToUTF8(value());
-}
-
 string16 FilePath::AsUTF16Unsafe() const {
   return value();
 }
 
 // static
-FilePath FilePath::FromUTF8Unsafe(const std::string& utf8) {
-  return FilePath(UTF8ToWide(utf8));
-}
-
-// static
 FilePath FilePath::FromUTF16Unsafe(const string16& utf16) {
   return FilePath(utf16);
 }
 #endif
 
-void FilePath::WriteToPickle(Pickle* pickle) const {
-#if defined(OS_WIN)
-  pickle->WriteString16(path_);
-#else
-  pickle->WriteString(path_);
-#endif
-}
-
-bool FilePath::ReadFromPickle(PickleIterator* iter) {
-#if defined(OS_WIN)
-  if (!iter->ReadString16(&path_))
-    return false;
-#else
-  if (!iter->ReadString(&path_))
-    return false;
-#endif
-
-  if (path_.find(kStringTerminator) != StringType::npos)
-    return false;
-
-  return true;
-}
-
 #if defined(OS_WIN)
 // Windows specific implementation of file string comparisons
 
@@ -1318,7 +1259,3 @@ bool FilePath::IsContentUri() const {
 #endif
 
 }  // namespace base
-
-void PrintTo(const base::FilePath& path, std::ostream* out) {
-  *out << path.value();
-}
diff --git a/base/files/file_path.h b/base/files/file_path.h
index 008b9f5..3c26f7f 100644
--- a/base/files/file_path.h
+++ b/base/files/file_path.h
@@ -108,7 +108,6 @@
 
 #include "base/base_export.h"
 #include "base/compiler_specific.h"
-#include "base/containers/hash_tables.h"
 #include "base/strings/string16.h"
 #include "base/strings/string_piece.h"  // For implicit conversions.
 #include "build/build_config.h"
@@ -267,8 +266,6 @@ class BASE_EXPORT FilePath {
   // path == "C:\pics.old\jojo" suffix == " (1)", returns "C:\pics.old\jojo (1)"
   FilePath InsertBeforeExtension(
       const StringType& suffix) const WARN_UNUSED_RESULT;
-  FilePath InsertBeforeExtensionASCII(
-      const base::StringPiece& suffix) const WARN_UNUSED_RESULT;
 
   // Adds |extension| to |file_name|. Returns the current FilePath if
   // |extension| is empty. Returns "" if BaseName() == "." or "..".
@@ -295,15 +292,6 @@ class BASE_EXPORT FilePath {
   FilePath Append(const StringType& component) const WARN_UNUSED_RESULT;
   FilePath Append(const FilePath& component) const WARN_UNUSED_RESULT;
 
-  // Although Windows StringType is std::wstring, since the encoding it uses for
-  // paths is well defined, it can handle ASCII path components as well.
-  // Mac uses UTF8, and since ASCII is a subset of that, it works there as well.
-  // On Linux, although it can use any 8-bit encoding for paths, we assume that
-  // ASCII is a valid subset, regardless of the encoding, since many operating
-  // system paths will always be ASCII.
-  FilePath AppendASCII(const base::StringPiece& component)
-      const WARN_UNUSED_RESULT;
-
   // Returns true if this FilePath contains an absolute path.  On Windows, an
   // absolute path begins with either a drive letter specification followed by
   // a separator character, or with two separator characters.  On POSIX
@@ -331,45 +319,12 @@ class BASE_EXPORT FilePath {
   // want to stuff a string16 into some other API.
   string16 LossyDisplayName() const;
 
-  // Return the path as ASCII, or the empty string if the path is not ASCII.
-  // This should only be used for cases where the FilePath is representing a
-  // known-ASCII filename.
-  std::string MaybeAsASCII() const;
-
-  // Return the path as UTF-8.
-  //
-  // This function is *unsafe* as there is no way to tell what encoding is
-  // used in file names on POSIX systems other than Mac and Chrome OS,
-  // although UTF-8 is practically used everywhere these days. To mitigate
-  // the encoding issue, this function internally calls
-  // SysNativeMBToWide() on POSIX systems other than Mac and Chrome OS,
-  // per assumption that the current locale's encoding is used in file
-  // names, but this isn't a perfect solution.
-  //
-  // Once it becomes safe to to stop caring about non-UTF-8 file names,
-  // the SysNativeMBToWide() hack will be removed from the code, along
-  // with "Unsafe" in the function name.
-  std::string AsUTF8Unsafe() const;
-
   // Similar to AsUTF8Unsafe, but returns UTF-16 instead.
   string16 AsUTF16Unsafe() const;
 
-  // Returns a FilePath object from a path name in UTF-8. This function
-  // should only be used for cases where you are sure that the input
-  // string is UTF-8.
-  //
-  // Like AsUTF8Unsafe(), this function is unsafe. This function
-  // internally calls SysWideToNativeMB() on POSIX systems other than Mac
-  // and Chrome OS, to mitigate the encoding issue. See the comment at
-  // AsUTF8Unsafe() for details.
-  static FilePath FromUTF8Unsafe(const std::string& utf8);
-
   // Similar to FromUTF8Unsafe, but accepts UTF-16 instead.
   static FilePath FromUTF16Unsafe(const string16& utf16);
 
-  void WriteToPickle(Pickle* pickle) const;
-  bool ReadFromPickle(PickleIterator* iter);
-
   // Normalize all path separators to backslash on Windows
   // (if FILE_PATH_USES_WIN_SEPARATORS is true), or do nothing on POSIX systems.
   FilePath NormalizePathSeparators() const;
@@ -435,9 +390,6 @@ class BASE_EXPORT FilePath {
 
 }  // namespace base
 
-// This is required by googletest to print a readable output on test failures.
-BASE_EXPORT extern void PrintTo(const base::FilePath& path, std::ostream* out);
-
 // Macros for string literal initialization of FilePath::CharType[], and for
 // using a FilePath::CharType[] in a printf-style format string.
 #if defined(OS_POSIX)
diff --git a/base/memory/singleton.h b/base/memory/singleton.h
index e5e2e3e..8fd177c 100644
--- a/base/memory/singleton.h
+++ b/base/memory/singleton.h
@@ -19,12 +19,10 @@
 #ifndef BASE_MEMORY_SINGLETON_H_
 #define BASE_MEMORY_SINGLETON_H_
 
-#include "base/at_exit.h"
 #include "base/atomicops.h"
 #include "base/base_export.h"
 #include "base/memory/aligned_memory.h"
 #include "base/third_party/dynamic_annotations/dynamic_annotations.h"
-#include "base/threading/thread_restrictions.h"
 
 namespace base {
 namespace internal {
@@ -227,12 +225,6 @@ class Singleton {
 
   // Return a pointer to the one true instance of the class.
   static Type* get() {
-#ifndef NDEBUG
-    // Avoid making TLS lookup on release builds.
-    if (!Traits::kAllowedToAccessOnNonjoinableThread)
-      base::ThreadRestrictions::AssertSingletonAllowed();
-#endif
-
     // The load has acquire memory ordering as the thread which reads the
     // instance_ pointer must acquire visibility over the singleton data.
     base::subtle::AtomicWord value = base::subtle::Acquire_Load(&instance_);
@@ -258,9 +250,6 @@ class Singleton {
       base::subtle::Release_Store(
           &instance_, reinterpret_cast<base::subtle::AtomicWord>(newval));
 
-      if (newval != NULL && Traits::kRegisterAtExit)
-        base::AtExitManager::RegisterCallback(OnExit, NULL);
-
       return newval;
     }
 
diff --git a/base/process/launch.h b/base/process/launch.h
index 261019b..97a303b 100644
--- a/base/process/launch.h
+++ b/base/process/launch.h
@@ -13,263 +13,23 @@
 
 #include "base/base_export.h"
 #include "base/basictypes.h"
-#include "base/environment.h"
-#include "base/process/process_handle.h"
 #include "base/strings/string_piece.h"
 
 #if defined(OS_POSIX)
 #include "base/posix/file_descriptor_shuffle.h"
 #elif defined(OS_WIN)
 #include <windows.h>
-#include "base/win/scoped_handle.h"
 #endif
 
 namespace base {
 
-class CommandLine;
-
-#if defined(OS_WIN)
-typedef std::vector<HANDLE> HandlesToInheritVector;
-#endif
-// TODO(viettrungluu): Only define this on POSIX?
-typedef std::vector<std::pair<int, int> > FileHandleMappingVector;
-
-// Options for launching a subprocess that are passed to LaunchProcess().
-// The default constructor constructs the object with default options.
-struct BASE_EXPORT LaunchOptions {
-  LaunchOptions();
-  ~LaunchOptions();
-
-  // If true, wait for the process to complete.
-  bool wait;
-
 #if defined(OS_WIN)
-  bool start_hidden;
-
-  // If non-null, inherit exactly the list of handles in this vector (these
-  // handles must be inheritable). This is only supported on Vista and higher.
-  HandlesToInheritVector* handles_to_inherit;
-
-  // If true, the new process inherits handles from the parent. In production
-  // code this flag should be used only when running short-lived, trusted
-  // binaries, because open handles from other libraries and subsystems will
-  // leak to the child process, causing errors such as open socket hangs.
-  // Note: If |handles_to_inherit| is non-null, this flag is ignored and only
-  // those handles will be inherited (on Vista and higher).
-  bool inherit_handles;
-
-  // If non-null, runs as if the user represented by the token had launched it.
-  // Whether the application is visible on the interactive desktop depends on
-  // the token belonging to an interactive logon session.
-  //
-  // To avoid hard to diagnose problems, when specified this loads the
-  // environment variables associated with the user and if this operation fails
-  // the entire call fails as well.
-  UserTokenHandle as_user;
-
-  // If true, use an empty string for the desktop name.
-  bool empty_desktop_name;
-
-  // If non-null, launches the application in that job object. The process will
-  // be terminated immediately and LaunchProcess() will fail if assignment to
-  // the job object fails.
-  HANDLE job_handle;
-
-  // Handles for the redirection of stdin, stdout and stderr. The handles must
-  // be inheritable. Caller should either set all three of them or none (i.e.
-  // there is no way to redirect stderr without redirecting stdin). The
-  // |inherit_handles| flag must be set to true when redirecting stdio stream.
-  HANDLE stdin_handle;
-  HANDLE stdout_handle;
-  HANDLE stderr_handle;
-
-  // If set to true, ensures that the child process is launched with the
-  // CREATE_BREAKAWAY_FROM_JOB flag which allows it to breakout of the parent
-  // job if any.
-  bool force_breakaway_from_job_;
-#else
-  // Set/unset environment variables. These are applied on top of the parent
-  // process environment.  Empty (the default) means to inherit the same
-  // environment. See AlterEnvironment().
-  EnvironmentMap environ;
-
-  // Clear the environment for the new process before processing changes from
-  // |environ|.
-  bool clear_environ;
-
-  // If non-null, remap file descriptors according to the mapping of
-  // src fd->dest fd to propagate FDs into the child process.
-  // This pointer is owned by the caller and must live through the
-  // call to LaunchProcess().
-  const FileHandleMappingVector* fds_to_remap;
-
-  // Each element is an RLIMIT_* constant that should be raised to its
-  // rlim_max.  This pointer is owned by the caller and must live through
-  // the call to LaunchProcess().
-  const std::vector<int>* maximize_rlimits;
-
-  // If true, start the process in a new process group, instead of
-  // inheriting the parent's process group.  The pgid of the child process
-  // will be the same as its pid.
-  bool new_process_group;
-
-#if defined(OS_LINUX)
-  // If non-zero, start the process using clone(), using flags as provided.
-  int clone_flags;
-
-  // By default, child processes will have the PR_SET_NO_NEW_PRIVS bit set. If
-  // true, then this bit will not be set in the new child process.
-  bool allow_new_privs;
-#endif  // defined(OS_LINUX)
-
-#if defined(OS_CHROMEOS)
-  // If non-negative, the specified file descriptor will be set as the launched
-  // process' controlling terminal.
-  int ctrl_terminal_fd;
-#endif  // defined(OS_CHROMEOS)
-
-#if defined(OS_MACOSX)
-  // If this name is non-empty, the new child, after fork() but before exec(),
-  // will look up this server name in the bootstrap namespace. The resulting
-  // service port will be replaced as the bootstrap port in the child. Because
-  // the process's IPC space is cleared on exec(), any rights to the old
-  // bootstrap port will not be transferred to the new process.
-  std::string replacement_bootstrap_name;
-#endif
-
-#endif  // !defined(OS_WIN)
-};
-
-// Launch a process via the command line |cmdline|.
-// See the documentation of LaunchOptions for details on |options|.
-//
-// Returns true upon success.
-//
-// Upon success, if |process_handle| is non-null, it will be filled in with the
-// handle of the launched process.  NOTE: In this case, the caller is
-// responsible for closing the handle so that it doesn't leak!
-// Otherwise, the process handle will be implicitly closed.
-//
-// Unix-specific notes:
-// - All file descriptors open in the parent process will be closed in the
-//   child process except for any preserved by options::fds_to_remap, and
-//   stdin, stdout, and stderr. If not remapped by options::fds_to_remap,
-//   stdin is reopened as /dev/null, and the child is allowed to inherit its
-//   parent's stdout and stderr.
-// - If the first argument on the command line does not contain a slash,
-//   PATH will be searched.  (See man execvp.)
-BASE_EXPORT bool LaunchProcess(const CommandLine& cmdline,
-                               const LaunchOptions& options,
-                               ProcessHandle* process_handle);
-
-#if defined(OS_WIN)
-// Windows-specific LaunchProcess that takes the command line as a
-// string.  Useful for situations where you need to control the
-// command line arguments directly, but prefer the CommandLine version
-// if launching Chrome itself.
-//
-// The first command line argument should be the path to the process,
-// and don't forget to quote it.
-//
-// Example (including literal quotes)
-//  cmdline = "c:\windows\explorer.exe" -foo "c:\bar\"
-BASE_EXPORT bool LaunchProcess(const string16& cmdline,
-                               const LaunchOptions& options,
-                               win::ScopedHandle* process_handle);
-
-// Launches a process with elevated privileges.  This does not behave exactly
-// like LaunchProcess as it uses ShellExecuteEx instead of CreateProcess to
-// create the process.  This means the process will have elevated privileges
-// and thus some common operations like OpenProcess will fail. The process will
-// be available through the |process_handle| argument.  Currently the only
-// supported LaunchOptions are |start_hidden| and |wait|.
-BASE_EXPORT bool LaunchElevatedProcess(const CommandLine& cmdline,
-                                       const LaunchOptions& options,
-                                       ProcessHandle* process_handle);
-
-#elif defined(OS_POSIX)
-// A POSIX-specific version of LaunchProcess that takes an argv array
-// instead of a CommandLine.  Useful for situations where you need to
-// control the command line arguments directly, but prefer the
-// CommandLine version if launching Chrome itself.
-BASE_EXPORT bool LaunchProcess(const std::vector<std::string>& argv,
-                               const LaunchOptions& options,
-                               ProcessHandle* process_handle);
-
-// Close all file descriptors, except those which are a destination in the
-// given multimap. Only call this function in a child process where you know
-// that there aren't any other threads.
-BASE_EXPORT void CloseSuperfluousFds(const InjectiveMultimap& saved_map);
-#endif  // defined(OS_POSIX)
-
-#if defined(OS_WIN)
-// Set |job_object|'s JOBOBJECT_EXTENDED_LIMIT_INFORMATION
-// BasicLimitInformation.LimitFlags to |limit_flags|.
-BASE_EXPORT bool SetJobObjectLimitFlags(HANDLE job_object, DWORD limit_flags);
 
 // Output multi-process printf, cout, cerr, etc to the cmd.exe console that ran
 // chrome. This is not thread-safe: only call from main thread.
 BASE_EXPORT void RouteStdioToConsole();
 #endif  // defined(OS_WIN)
 
-// Executes the application specified by |cl| and wait for it to exit. Stores
-// the output (stdout) in |output|. Redirects stderr to /dev/null. Returns true
-// on success (application launched and exited cleanly, with exit code
-// indicating success).
-BASE_EXPORT bool GetAppOutput(const CommandLine& cl, std::string* output);
-
-#if defined(OS_WIN)
-// A Windows-specific version of GetAppOutput that takes a command line string
-// instead of a CommandLine object. Useful for situations where you need to
-// control the command line arguments directly.
-BASE_EXPORT bool GetAppOutput(const StringPiece16& cl, std::string* output);
-#endif
-
-#if defined(OS_POSIX)
-// A POSIX-specific version of GetAppOutput that takes an argv array
-// instead of a CommandLine.  Useful for situations where you need to
-// control the command line arguments directly.
-BASE_EXPORT bool GetAppOutput(const std::vector<std::string>& argv,
-                              std::string* output);
-
-// A restricted version of |GetAppOutput()| which (a) clears the environment,
-// and (b) stores at most |max_output| bytes; also, it doesn't search the path
-// for the command.
-BASE_EXPORT bool GetAppOutputRestricted(const CommandLine& cl,
-                                        std::string* output, size_t max_output);
-
-// A version of |GetAppOutput()| which also returns the exit code of the
-// executed command. Returns true if the application runs and exits cleanly. If
-// this is the case the exit code of the application is available in
-// |*exit_code|.
-BASE_EXPORT bool GetAppOutputWithExitCode(const CommandLine& cl,
-                                          std::string* output, int* exit_code);
-#endif  // defined(OS_POSIX)
-
-// If supported on the platform, and the user has sufficent rights, increase
-// the current process's scheduling priority to a high priority.
-BASE_EXPORT void RaiseProcessToHighPriority();
-
-#if defined(OS_MACOSX)
-// Restore the default exception handler, setting it to Apple Crash Reporter
-// (ReportCrash).  When forking and execing a new process, the child will
-// inherit the parent's exception ports, which may be set to the Breakpad
-// instance running inside the parent.  The parent's Breakpad instance should
-// not handle the child's exceptions.  Calling RestoreDefaultExceptionHandler
-// in the child after forking will restore the standard exception handler.
-// See http://crbug.com/20371/ for more details.
-void RestoreDefaultExceptionHandler();
-
-// Look up the bootstrap server named |replacement_bootstrap_name| via the
-// current |bootstrap_port|. Then replace the task's bootstrap port with the
-// received right.
-void ReplaceBootstrapPort(const std::string& replacement_bootstrap_name);
-#endif  // defined(OS_MACOSX)
-
-// Creates a LaunchOptions object suitable for launching processes in a test
-// binary. This should not be called in production/released code.
-BASE_EXPORT LaunchOptions LaunchOptionsForTest();
-
 }  // namespace base
 
 #endif  // BASE_PROCESS_LAUNCH_H_
diff --git a/base/process/launch_win.cc b/base/process/launch_win.cc
index a3303a5..d8f9d40 100644
--- a/base/process/launch_win.cc
+++ b/base/process/launch_win.cc
@@ -14,23 +14,6 @@
 #include <ios>
 #include <limits>
 
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/command_line.h"
-#include "base/debug/stack_trace.h"
-#include "base/logging.h"
-#include "base/memory/scoped_ptr.h"
-#include "base/message_loop/message_loop.h"
-#include "base/metrics/histogram.h"
-#include "base/process/kill.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/sys_info.h"
-#include "base/win/object_watcher.h"
-#include "base/win/scoped_handle.h"
-#include "base/win/scoped_process_information.h"
-#include "base/win/startup_information.h"
-#include "base/win/windows_version.h"
-
 // userenv.dll is required for CreateEnvironmentBlock().
 #pragma comment(lib, "userenv.lib")
 
@@ -105,268 +88,4 @@ void RouteStdioToConsole() {
   std::ios::sync_with_stdio();
 }
 
-bool LaunchProcess(const string16& cmdline,
-                   const LaunchOptions& options,
-                   win::ScopedHandle* process_handle) {
-  win::StartupInformation startup_info_wrapper;
-  STARTUPINFO* startup_info = startup_info_wrapper.startup_info();
-
-  bool inherit_handles = options.inherit_handles;
-  DWORD flags = 0;
-  if (options.handles_to_inherit) {
-    if (options.handles_to_inherit->empty()) {
-      inherit_handles = false;
-    } else {
-      if (base::win::GetVersion() < base::win::VERSION_VISTA) {
-        DLOG(ERROR) << "Specifying handles to inherit requires Vista or later.";
-        return false;
-      }
-
-      if (options.handles_to_inherit->size() >
-              std::numeric_limits<DWORD>::max() / sizeof(HANDLE)) {
-        DLOG(ERROR) << "Too many handles to inherit.";
-        return false;
-      }
-
-      if (!startup_info_wrapper.InitializeProcThreadAttributeList(1)) {
-        DPLOG(ERROR);
-        return false;
-      }
-
-      if (!startup_info_wrapper.UpdateProcThreadAttribute(
-              PROC_THREAD_ATTRIBUTE_HANDLE_LIST,
-              const_cast<HANDLE*>(&options.handles_to_inherit->at(0)),
-              static_cast<DWORD>(options.handles_to_inherit->size() *
-                  sizeof(HANDLE)))) {
-        DPLOG(ERROR);
-        return false;
-      }
-
-      inherit_handles = true;
-      flags |= EXTENDED_STARTUPINFO_PRESENT;
-    }
-  }
-
-  if (options.empty_desktop_name)
-    startup_info->lpDesktop = const_cast<wchar_t*>(L"");
-  startup_info->dwFlags = STARTF_USESHOWWINDOW;
-  startup_info->wShowWindow = options.start_hidden ? SW_HIDE : SW_SHOW;
-
-  if (options.stdin_handle || options.stdout_handle || options.stderr_handle) {
-    DCHECK(inherit_handles);
-    DCHECK(options.stdin_handle);
-    DCHECK(options.stdout_handle);
-    DCHECK(options.stderr_handle);
-    startup_info->dwFlags |= STARTF_USESTDHANDLES;
-    startup_info->hStdInput = options.stdin_handle;
-    startup_info->hStdOutput = options.stdout_handle;
-    startup_info->hStdError = options.stderr_handle;
-  }
-
-  if (options.job_handle) {
-    flags |= CREATE_SUSPENDED;
-
-    // If this code is run under a debugger, the launched process is
-    // automatically associated with a job object created by the debugger.
-    // The CREATE_BREAKAWAY_FROM_JOB flag is used to prevent this.
-    flags |= CREATE_BREAKAWAY_FROM_JOB;
-  }
-
-  if (options.force_breakaway_from_job_)
-    flags |= CREATE_BREAKAWAY_FROM_JOB;
-
-  PROCESS_INFORMATION temp_process_info = {};
-
-  string16 writable_cmdline(cmdline);
-  if (options.as_user) {
-    flags |= CREATE_UNICODE_ENVIRONMENT;
-    void* enviroment_block = NULL;
-
-    if (!CreateEnvironmentBlock(&enviroment_block, options.as_user, FALSE)) {
-      DPLOG(ERROR);
-      return false;
-    }
-
-    BOOL launched =
-        CreateProcessAsUser(options.as_user, NULL,
-                            &writable_cmdline[0],
-                            NULL, NULL, inherit_handles, flags,
-                            enviroment_block, NULL, startup_info,
-                            &temp_process_info);
-    DestroyEnvironmentBlock(enviroment_block);
-    if (!launched) {
-      DPLOG(ERROR) << "Command line:" << std::endl << UTF16ToUTF8(cmdline)
-                   << std::endl;;
-      return false;
-    }
-  } else {
-    if (!CreateProcess(NULL,
-                       &writable_cmdline[0], NULL, NULL,
-                       inherit_handles, flags, NULL, NULL,
-                       startup_info, &temp_process_info)) {
-      DPLOG(ERROR) << "Command line:" << std::endl << UTF16ToUTF8(cmdline)
-                   << std::endl;;
-      return false;
-    }
-  }
-  base::win::ScopedProcessInformation process_info(temp_process_info);
-
-  if (options.job_handle) {
-    if (0 == AssignProcessToJobObject(options.job_handle,
-                                      process_info.process_handle())) {
-      DLOG(ERROR) << "Could not AssignProcessToObject.";
-      KillProcess(process_info.process_handle(), kProcessKilledExitCode, true);
-      return false;
-    }
-
-    ResumeThread(process_info.thread_handle());
-  }
-
-  if (options.wait)
-    WaitForSingleObject(process_info.process_handle(), INFINITE);
-
-  // If the caller wants the process handle, we won't close it.
-  if (process_handle)
-    process_handle->Set(process_info.TakeProcessHandle());
-
-  return true;
-}
-
-bool LaunchProcess(const CommandLine& cmdline,
-                   const LaunchOptions& options,
-                   ProcessHandle* process_handle) {
-  if (!process_handle)
-    return LaunchProcess(cmdline.GetCommandLineString(), options, NULL);
-
-  win::ScopedHandle process;
-  bool rv = LaunchProcess(cmdline.GetCommandLineString(), options, &process);
-  *process_handle = process.Take();
-  return rv;
-}
-
-bool LaunchElevatedProcess(const CommandLine& cmdline,
-                           const LaunchOptions& options,
-                           ProcessHandle* process_handle) {
-  const string16 file = cmdline.GetProgram().value();
-  const string16 arguments = cmdline.GetArgumentsString();
-
-  SHELLEXECUTEINFO shex_info = {0};
-  shex_info.cbSize = sizeof(shex_info);
-  shex_info.fMask = SEE_MASK_NOCLOSEPROCESS;
-  shex_info.hwnd = GetActiveWindow();
-  shex_info.lpVerb = L"runas";
-  shex_info.lpFile = file.c_str();
-  shex_info.lpParameters = arguments.c_str();
-  shex_info.lpDirectory = NULL;
-  shex_info.nShow = options.start_hidden ? SW_HIDE : SW_SHOW;
-  shex_info.hInstApp = NULL;
-
-  if (!ShellExecuteEx(&shex_info)) {
-    DPLOG(ERROR);
-    return false;
-  }
-
-  if (options.wait)
-    WaitForSingleObject(shex_info.hProcess, INFINITE);
-
-  // If the caller wants the process handle give it to them, otherwise just
-  // close it.  Closing it does not terminate the process.
-  if (process_handle)
-    *process_handle = shex_info.hProcess;
-  else
-    CloseHandle(shex_info.hProcess);
-
-  return true;
-}
-
-bool SetJobObjectLimitFlags(HANDLE job_object, DWORD limit_flags) {
-  JOBOBJECT_EXTENDED_LIMIT_INFORMATION limit_info = {0};
-  limit_info.BasicLimitInformation.LimitFlags = limit_flags;
-  return 0 != SetInformationJobObject(
-      job_object,
-      JobObjectExtendedLimitInformation,
-      &limit_info,
-      sizeof(limit_info));
-}
-
-bool GetAppOutput(const CommandLine& cl, std::string* output) {
-  return GetAppOutput(cl.GetCommandLineString(), output);
-}
-
-bool GetAppOutput(const StringPiece16& cl, std::string* output) {
-  HANDLE out_read = NULL;
-  HANDLE out_write = NULL;
-
-  SECURITY_ATTRIBUTES sa_attr;
-  // Set the bInheritHandle flag so pipe handles are inherited.
-  sa_attr.nLength = sizeof(SECURITY_ATTRIBUTES);
-  sa_attr.bInheritHandle = TRUE;
-  sa_attr.lpSecurityDescriptor = NULL;
-
-  // Create the pipe for the child process's STDOUT.
-  if (!CreatePipe(&out_read, &out_write, &sa_attr, 0)) {
-    NOTREACHED() << "Failed to create pipe";
-    return false;
-  }
-
-  // Ensure we don't leak the handles.
-  win::ScopedHandle scoped_out_read(out_read);
-  win::ScopedHandle scoped_out_write(out_write);
-
-  // Ensure the read handle to the pipe for STDOUT is not inherited.
-  if (!SetHandleInformation(out_read, HANDLE_FLAG_INHERIT, 0)) {
-    NOTREACHED() << "Failed to disabled pipe inheritance";
-    return false;
-  }
-
-  FilePath::StringType writable_command_line_string;
-  writable_command_line_string.assign(cl.data(), cl.size());
-
-  STARTUPINFO start_info = {};
-
-  start_info.cb = sizeof(STARTUPINFO);
-  start_info.hStdOutput = out_write;
-  // Keep the normal stdin and stderr.
-  start_info.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
-  start_info.hStdError = GetStdHandle(STD_ERROR_HANDLE);
-  start_info.dwFlags |= STARTF_USESTDHANDLES;
-
-  // Create the child process.
-  PROCESS_INFORMATION temp_process_info = {};
-  if (!CreateProcess(NULL,
-                     &writable_command_line_string[0],
-                     NULL, NULL,
-                     TRUE,  // Handles are inherited.
-                     0, NULL, NULL, &start_info, &temp_process_info)) {
-    NOTREACHED() << "Failed to start process";
-    return false;
-  }
-  base::win::ScopedProcessInformation proc_info(temp_process_info);
-
-  // Close our writing end of pipe now. Otherwise later read would not be able
-  // to detect end of child's output.
-  scoped_out_write.Close();
-
-  // Read output from the child process's pipe for STDOUT
-  const int kBufferSize = 1024;
-  char buffer[kBufferSize];
-
-  for (;;) {
-    DWORD bytes_read = 0;
-    BOOL success = ReadFile(out_read, buffer, kBufferSize, &bytes_read, NULL);
-    if (!success || bytes_read == 0)
-      break;
-    output->append(buffer, bytes_read);
-  }
-
-  // Let's wait for the process to finish.
-  WaitForSingleObject(proc_info.process_handle(), INFINITE);
-
-  return true;
-}
-
-void RaiseProcessToHighPriority() {
-  SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);
-}
-
 }  // namespace base
diff --git a/base/strings/string_piece.h b/base/strings/string_piece.h
index a051bc8..2185e7e 100644
--- a/base/strings/string_piece.h
+++ b/base/strings/string_piece.h
@@ -35,7 +35,6 @@
 
 #include "base/base_export.h"
 #include "base/basictypes.h"
-#include "base/containers/hash_tables.h"
 #include "base/strings/string16.h"
 
 namespace base {
diff --git a/base/strings/string_util.cc b/base/strings/string_util.cc
index 43f15a3..e28260e 100644
--- a/base/strings/string_util.cc
+++ b/base/strings/string_util.cc
@@ -19,12 +19,8 @@
 #include <vector>
 
 #include "base/basictypes.h"
-#include "base/logging.h"
-#include "base/memory/singleton.h"
-#include "base/strings/utf_string_conversion_utils.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/third_party/icu/icu_utf.h"
 #include "build/build_config.h"
+#include "glog/logging.h"
 
 // Remove when this entire file is in the base namespace.
 using base::char16;
@@ -32,19 +28,6 @@ using base::string16;
 
 namespace {
 
-// Force the singleton used by EmptyString[16] to be a unique type. This
-// prevents other code that might accidentally use Singleton<string> from
-// getting our internal one.
-struct EmptyStrings {
-  EmptyStrings() {}
-  const std::string s;
-  const string16 s16;
-
-  static EmptyStrings* GetInstance() {
-    return Singleton<EmptyStrings>::get();
-  }
-};
-
 // Used by ReplaceStringPlaceholders to track the position in the string of
 // replaced parameters.
 struct ReplacementOffset {
@@ -139,14 +122,6 @@ bool IsWprintfFormatPortable(const wchar_t* format) {
   return true;
 }
 
-const std::string& EmptyString() {
-  return EmptyStrings::GetInstance()->s;
-}
-
-const string16& EmptyString16() {
-  return EmptyStrings::GetInstance()->s16;
-}
-
 template<typename STR>
 bool ReplaceCharsT(const STR& input,
                    const STR& replace_chars,
@@ -239,42 +214,6 @@ bool TrimString(const std::string& input,
       TRIM_NONE;
 }
 
-void TruncateUTF8ToByteSize(const std::string& input,
-                            const size_t byte_size,
-                            std::string* output) {
-  DCHECK(output);
-  if (byte_size > input.length()) {
-    *output = input;
-    return;
-  }
-  DCHECK_LE(byte_size, static_cast<uint32>(kint32max));
-  // Note: This cast is necessary because CBU8_NEXT uses int32s.
-  int32 truncation_length = static_cast<int32>(byte_size);
-  int32 char_index = truncation_length - 1;
-  const char* data = input.data();
-
-  // Using CBU8, we will move backwards from the truncation point
-  // to the beginning of the string looking for a valid UTF8
-  // character.  Once a full UTF8 character is found, we will
-  // truncate the string to the end of that character.
-  while (char_index >= 0) {
-    int32 prev = char_index;
-    base_icu::UChar32 code_point = 0;
-    CBU8_NEXT(data, char_index, truncation_length, code_point);
-    if (!IsValidCharacter(code_point) ||
-        !IsValidCodepoint(code_point)) {
-      char_index = prev - 1;
-    } else {
-      break;
-    }
-  }
-
-  if (char_index >= 0 )
-    *output = input.substr(0, char_index);
-  else
-    output->clear();
-}
-
 TrimPositions TrimWhitespace(const string16& input,
                              TrimPositions positions,
                              string16* output) {
@@ -406,20 +345,6 @@ bool IsStringASCII(const std::wstring& str) {
 }
 #endif
 
-bool IsStringUTF8(const std::string& str) {
-  const char *src = str.data();
-  int32 src_len = static_cast<int32>(str.length());
-  int32 char_index = 0;
-
-  while (char_index < src_len) {
-    int32 code_point;
-    CBU8_NEXT(src, char_index, src_len, code_point);
-    if (!IsValidCharacter(code_point))
-      return false;
-  }
-  return true;
-}
-
 }  // namespace base
 
 template<typename Iter>
@@ -534,28 +459,6 @@ static const char* const kByteStringsUnlocalized[] = {
   " PB"
 };
 
-string16 FormatBytesUnlocalized(int64 bytes) {
-  double unit_amount = static_cast<double>(bytes);
-  size_t dimension = 0;
-  const int kKilo = 1024;
-  while (unit_amount >= kKilo &&
-         dimension < arraysize(kByteStringsUnlocalized) - 1) {
-    unit_amount /= kKilo;
-    dimension++;
-  }
-
-  char buf[64];
-  if (bytes != 0 && dimension > 0 && unit_amount < 100) {
-    base::snprintf(buf, arraysize(buf), "%.1lf%s", unit_amount,
-                   kByteStringsUnlocalized[dimension]);
-  } else {
-    base::snprintf(buf, arraysize(buf), "%.0lf%s", unit_amount,
-                   kByteStringsUnlocalized[dimension]);
-  }
-
-  return base::ASCIIToUTF16(buf);
-}
-
 template<class StringType>
 void DoReplaceSubstringsAfterOffset(StringType* str,
                                     size_t start_offset,
@@ -771,161 +674,6 @@ string16 ReplaceStringPlaceholders(const string16& format_string,
   return result;
 }
 
-static bool IsWildcard(base_icu::UChar32 character) {
-  return character == '*' || character == '?';
-}
-
-// Move the strings pointers to the point where they start to differ.
-template <typename CHAR, typename NEXT>
-static void EatSameChars(const CHAR** pattern, const CHAR* pattern_end,
-                         const CHAR** string, const CHAR* string_end,
-                         NEXT next) {
-  const CHAR* escape = NULL;
-  while (*pattern != pattern_end && *string != string_end) {
-    if (!escape && IsWildcard(**pattern)) {
-      // We don't want to match wildcard here, except if it's escaped.
-      return;
-    }
-
-    // Check if the escapement char is found. If so, skip it and move to the
-    // next character.
-    if (!escape && **pattern == '\\') {
-      escape = *pattern;
-      next(pattern, pattern_end);
-      continue;
-    }
-
-    // Check if the chars match, if so, increment the ptrs.
-    const CHAR* pattern_next = *pattern;
-    const CHAR* string_next = *string;
-    base_icu::UChar32 pattern_char = next(&pattern_next, pattern_end);
-    if (pattern_char == next(&string_next, string_end) &&
-        pattern_char != CBU_SENTINEL) {
-      *pattern = pattern_next;
-      *string = string_next;
-    } else {
-      // Uh oh, it did not match, we are done. If the last char was an
-      // escapement, that means that it was an error to advance the ptr here,
-      // let's put it back where it was. This also mean that the MatchPattern
-      // function will return false because if we can't match an escape char
-      // here, then no one will.
-      if (escape) {
-        *pattern = escape;
-      }
-      return;
-    }
-
-    escape = NULL;
-  }
-}
-
-template <typename CHAR, typename NEXT>
-static void EatWildcard(const CHAR** pattern, const CHAR* end, NEXT next) {
-  while (*pattern != end) {
-    if (!IsWildcard(**pattern))
-      return;
-    next(pattern, end);
-  }
-}
-
-template <typename CHAR, typename NEXT>
-static bool MatchPatternT(const CHAR* eval, const CHAR* eval_end,
-                          const CHAR* pattern, const CHAR* pattern_end,
-                          int depth,
-                          NEXT next) {
-  const int kMaxDepth = 16;
-  if (depth > kMaxDepth)
-    return false;
-
-  // Eat all the matching chars.
-  EatSameChars(&pattern, pattern_end, &eval, eval_end, next);
-
-  // If the string is empty, then the pattern must be empty too, or contains
-  // only wildcards.
-  if (eval == eval_end) {
-    EatWildcard(&pattern, pattern_end, next);
-    return pattern == pattern_end;
-  }
-
-  // Pattern is empty but not string, this is not a match.
-  if (pattern == pattern_end)
-    return false;
-
-  // If this is a question mark, then we need to compare the rest with
-  // the current string or the string with one character eaten.
-  const CHAR* next_pattern = pattern;
-  next(&next_pattern, pattern_end);
-  if (pattern[0] == '?') {
-    if (MatchPatternT(eval, eval_end, next_pattern, pattern_end,
-                      depth + 1, next))
-      return true;
-    const CHAR* next_eval = eval;
-    next(&next_eval, eval_end);
-    if (MatchPatternT(next_eval, eval_end, next_pattern, pattern_end,
-                      depth + 1, next))
-      return true;
-  }
-
-  // This is a *, try to match all the possible substrings with the remainder
-  // of the pattern.
-  if (pattern[0] == '*') {
-    // Collapse duplicate wild cards (********** into *) so that the
-    // method does not recurse unnecessarily. http://crbug.com/52839
-    EatWildcard(&next_pattern, pattern_end, next);
-
-    while (eval != eval_end) {
-      if (MatchPatternT(eval, eval_end, next_pattern, pattern_end,
-                        depth + 1, next))
-        return true;
-      eval++;
-    }
-
-    // We reached the end of the string, let see if the pattern contains only
-    // wildcards.
-    if (eval == eval_end) {
-      EatWildcard(&pattern, pattern_end, next);
-      if (pattern != pattern_end)
-        return false;
-      return true;
-    }
-  }
-
-  return false;
-}
-
-struct NextCharUTF8 {
-  base_icu::UChar32 operator()(const char** p, const char* end) {
-    base_icu::UChar32 c;
-    int offset = 0;
-    CBU8_NEXT(*p, offset, end - *p, c);
-    *p += offset;
-    return c;
-  }
-};
-
-struct NextCharUTF16 {
-  base_icu::UChar32 operator()(const char16** p, const char16* end) {
-    base_icu::UChar32 c;
-    int offset = 0;
-    CBU16_NEXT(*p, offset, end - *p, c);
-    *p += offset;
-    return c;
-  }
-};
-
-bool MatchPattern(const base::StringPiece& eval,
-                  const base::StringPiece& pattern) {
-  return MatchPatternT(eval.data(), eval.data() + eval.size(),
-                       pattern.data(), pattern.data() + pattern.size(),
-                       0, NextCharUTF8());
-}
-
-bool MatchPattern(const string16& eval, const string16& pattern) {
-  return MatchPatternT(eval.c_str(), eval.c_str() + eval.size(),
-                       pattern.c_str(), pattern.c_str() + pattern.size(),
-                       0, NextCharUTF16());
-}
-
 // The following code is compatible with the OpenBSD lcpy interface.  See:
 //   http://www.gratisoft.us/todd/papers/strlcpy.html
 //   ftp://ftp.openbsd.org/pub/OpenBSD/src/lib/libc/string/{wcs,str}lcpy.c
diff --git a/base/strings/string_util.h b/base/strings/string_util.h
index 1e2ac70..7d0e54b 100644
--- a/base/strings/string_util.h
+++ b/base/strings/string_util.h
@@ -121,22 +121,6 @@ template<typename Char> struct CaseInsensitiveCompareASCII {
   }
 };
 
-// These threadsafe functions return references to globally unique empty
-// strings.
-//
-// It is likely faster to construct a new empty string object (just a few
-// instructions to set the length to 0) than to get the empty string singleton
-// returned by these functions (which requires threadsafe singleton access).
-//
-// Therefore, DO NOT USE THESE AS A GENERAL-PURPOSE SUBSTITUTE FOR DEFAULT
-// CONSTRUCTORS. There is only one case where you should use these: functions
-// which need to return a string by reference (e.g. as a class member
-// accessor), and don't have an empty string to use (e.g. in an error case).
-// These should not be used as initializers, function arguments, or return
-// values for functions which return by value or outparam.
-BASE_EXPORT const std::string& EmptyString();
-BASE_EXPORT const string16& EmptyString16();
-
 // Contains the set of characters representing whitespace in the corresponding
 // encoding. Null-terminated.
 BASE_EXPORT extern const wchar_t kWhitespaceWide[];
@@ -180,12 +164,6 @@ BASE_EXPORT bool TrimString(const std::string& input,
                             const base::StringPiece& trim_chars,
                             std::string* output);
 
-// Truncates a string to the nearest UTF-8 character that will leave
-// the string less than or equal to the specified byte size.
-BASE_EXPORT void TruncateUTF8ToByteSize(const std::string& input,
-                                        const size_t byte_size,
-                                        std::string* output);
-
 // Trims any whitespace from either end of the input string.  Returns where
 // whitespace was found.
 // The non-wide version has two functions:
@@ -248,7 +226,6 @@ BASE_EXPORT bool ContainsOnlyChars(const StringPiece16& input,
 //
 // IsStringASCII assumes the input is likely all ASCII, and does not leave early
 // if it is not the case.
-BASE_EXPORT bool IsStringUTF8(const std::string& str);
 BASE_EXPORT bool IsStringASCII(const StringPiece& str);
 BASE_EXPORT bool IsStringASCII(const StringPiece16& str);
 // A convenience adaptor for WebStrings, as they don't convert into
@@ -377,12 +354,6 @@ inline bool IsWhitespace(wchar_t c) {
   return wcschr(base::kWhitespaceWide, c) != NULL;
 }
 
-// Return a byte string in human-readable format with a unit suffix. Not
-// appropriate for use in any UI; use of FormatBytes and friends in ui/base is
-// highly recommended instead. TODO(avi): Figure out how to get callers to use
-// FormatBytes instead; remove this.
-BASE_EXPORT base::string16 FormatBytesUnlocalized(int64 bytes);
-
 // Starting at |start_offset| (usually 0), replace the first instance of
 // |find_this| with |replace_with|.
 BASE_EXPORT void ReplaceFirstSubstringAfterOffset(
diff --git a/base/strings/string_util_win.h b/base/strings/string_util_win.h
index 602ba27..f4654e0 100644
--- a/base/strings/string_util_win.h
+++ b/base/strings/string_util_win.h
@@ -10,7 +10,7 @@
 #include <string.h>
 #include <wchar.h>
 
-#include "base/logging.h"
+#include "glog/logging.h"
 
 namespace base {
 
diff --git a/base/synchronization/lock.cc b/base/synchronization/lock.cc
index b1576c5..20016cf 100644
--- a/base/synchronization/lock.cc
+++ b/base/synchronization/lock.cc
@@ -9,30 +9,19 @@
 #if !defined(NDEBUG) || defined(DCHECK_ALWAYS_ON)
 
 #include "base/synchronization/lock.h"
-#include "base/logging.h"
+#include "glog/logging.h"
 
 namespace base {
 
-Lock::Lock() : lock_() {
-}
+Lock::Lock() : lock_() {}
 
-Lock::~Lock() {
-  DCHECK(owning_thread_ref_.is_null());
-}
+Lock::~Lock() {}
 
-void Lock::AssertAcquired() const {
-  DCHECK(owning_thread_ref_ == PlatformThread::CurrentRef());
-}
+void Lock::AssertAcquired() const {}
 
-void Lock::CheckHeldAndUnmark() {
-  DCHECK(owning_thread_ref_ == PlatformThread::CurrentRef());
-  owning_thread_ref_ = PlatformThreadRef();
-}
+void Lock::CheckHeldAndUnmark() {}
 
-void Lock::CheckUnheldAndMark() {
-  DCHECK(owning_thread_ref_.is_null());
-  owning_thread_ref_ = PlatformThread::CurrentRef();
-}
+void Lock::CheckUnheldAndMark() {}
 
 }  // namespace base
 
diff --git a/base/threading/platform_thread.h b/base/threading/platform_thread.h
index 2874314..e23e52c 100644
--- a/base/threading/platform_thread.h
+++ b/base/threading/platform_thread.h
@@ -11,7 +11,6 @@
 
 #include "base/base_export.h"
 #include "base/basictypes.h"
-#include "base/time/time.h"
 #include "build/build_config.h"
 
 #if defined(OS_WIN)
@@ -110,87 +109,11 @@ class PlatformThreadHandle {
 
 const PlatformThreadId kInvalidThreadId(0);
 
-// Valid values for SetThreadPriority()
-enum ThreadPriority{
-  kThreadPriority_Normal,
-  // Suitable for low-latency, glitch-resistant audio.
-  kThreadPriority_RealtimeAudio,
-  // Suitable for threads which generate data for the display (at ~60Hz).
-  kThreadPriority_Display,
-  // Suitable for threads that shouldn't disrupt high priority work.
-  kThreadPriority_Background
-};
-
 // A namespace for low-level thread functions.
 class BASE_EXPORT PlatformThread {
  public:
-  // Implement this interface to run code on a background thread.  Your
-  // ThreadMain method will be called on the newly created thread.
-  class BASE_EXPORT Delegate {
-   public:
-    virtual void ThreadMain() = 0;
-
-   protected:
-    virtual ~Delegate() {}
-  };
-
-  // Gets the current thread id, which may be useful for logging purposes.
-  static PlatformThreadId CurrentId();
-
-  // Gets the current thread reference, which can be used to check if
-  // we're on the right thread quickly.
-  static PlatformThreadRef CurrentRef();
-
-  // Get the current handle.
-  static PlatformThreadHandle CurrentHandle();
-
   // Yield the current thread so another thread can be scheduled.
   static void YieldCurrentThread();
-
-  // Sleeps for the specified duration.
-  static void Sleep(base::TimeDelta duration);
-
-  // Sets the thread name visible to debuggers/tools. This has no effect
-  // otherwise. This name pointer is not copied internally. Thus, it must stay
-  // valid until the thread ends.
-  static void SetName(const char* name);
-
-  // Gets the thread name, if previously set by SetName.
-  static const char* GetName();
-
-  // Creates a new thread.  The |stack_size| parameter can be 0 to indicate
-  // that the default stack size should be used.  Upon success,
-  // |*thread_handle| will be assigned a handle to the newly created thread,
-  // and |delegate|'s ThreadMain method will be executed on the newly created
-  // thread.
-  // NOTE: When you are done with the thread handle, you must call Join to
-  // release system resources associated with the thread.  You must ensure that
-  // the Delegate object outlives the thread.
-  static bool Create(size_t stack_size, Delegate* delegate,
-                     PlatformThreadHandle* thread_handle);
-
-  // CreateWithPriority() does the same thing as Create() except the priority of
-  // the thread is set based on |priority|.  Can be used in place of Create()
-  // followed by SetThreadPriority().  SetThreadPriority() has not been
-  // implemented on the Linux platform yet, this is the only way to get a high
-  // priority thread on Linux.
-  static bool CreateWithPriority(size_t stack_size, Delegate* delegate,
-                                 PlatformThreadHandle* thread_handle,
-                                 ThreadPriority priority);
-
-  // CreateNonJoinable() does the same thing as Create() except the thread
-  // cannot be Join()'d.  Therefore, it also does not output a
-  // PlatformThreadHandle.
-  static bool CreateNonJoinable(size_t stack_size, Delegate* delegate);
-
-  // Joins with a thread created via the Create function.  This function blocks
-  // the caller until the designated thread exits.  This will invalidate
-  // |thread_handle|.
-  static void Join(PlatformThreadHandle thread_handle);
-
-  static void SetThreadPriority(PlatformThreadHandle handle,
-                                ThreadPriority priority);
-
  private:
   DISALLOW_IMPLICIT_CONSTRUCTORS(PlatformThread);
 };
diff --git a/base/threading/platform_thread_win.cc b/base/threading/platform_thread_win.cc
index 3df3719..89b0c47 100644
--- a/base/threading/platform_thread_win.cc
+++ b/base/threading/platform_thread_win.cc
@@ -4,247 +4,11 @@
 
 #include "base/threading/platform_thread.h"
 
-#include "base/debug/alias.h"
-#include "base/debug/profiler.h"
-#include "base/logging.h"
-#include "base/threading/thread_id_name_manager.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/tracked_objects.h"
-#include "base/win/scoped_handle.h"
-#include "base/win/windows_version.h"
-
 namespace base {
 
-namespace {
-
-// The information on how to set the thread name comes from
-// a MSDN article: http://msdn2.microsoft.com/en-us/library/xcb2z8hs.aspx
-const DWORD kVCThreadNameException = 0x406D1388;
-
-typedef struct tagTHREADNAME_INFO {
-  DWORD dwType;  // Must be 0x1000.
-  LPCSTR szName;  // Pointer to name (in user addr space).
-  DWORD dwThreadID;  // Thread ID (-1=caller thread).
-  DWORD dwFlags;  // Reserved for future use, must be zero.
-} THREADNAME_INFO;
-
-// This function has try handling, so it is separated out of its caller.
-void SetNameInternal(PlatformThreadId thread_id, const char* name) {
-  THREADNAME_INFO info;
-  info.dwType = 0x1000;
-  info.szName = name;
-  info.dwThreadID = thread_id;
-  info.dwFlags = 0;
-
-  __try {
-    RaiseException(kVCThreadNameException, 0, sizeof(info)/sizeof(DWORD),
-                   reinterpret_cast<DWORD_PTR*>(&info));
-  } __except(EXCEPTION_CONTINUE_EXECUTION) {
-  }
-}
-
-struct ThreadParams {
-  PlatformThread::Delegate* delegate;
-  bool joinable;
-};
-
-DWORD __stdcall ThreadFunc(void* params) {
-  ThreadParams* thread_params = static_cast<ThreadParams*>(params);
-  PlatformThread::Delegate* delegate = thread_params->delegate;
-  if (!thread_params->joinable)
-    base::ThreadRestrictions::SetSingletonAllowed(false);
-
-  // Retrieve a copy of the thread handle to use as the key in the
-  // thread name mapping.
-  PlatformThreadHandle::Handle platform_handle;
-  BOOL did_dup = DuplicateHandle(GetCurrentProcess(),
-                                GetCurrentThread(),
-                                GetCurrentProcess(),
-                                &platform_handle,
-                                0,
-                                FALSE,
-                                DUPLICATE_SAME_ACCESS);
-
-  win::ScopedHandle scoped_platform_handle;
-
-  if (did_dup) {
-    scoped_platform_handle.Set(platform_handle);
-    ThreadIdNameManager::GetInstance()->RegisterThread(
-        scoped_platform_handle.Get(),
-        PlatformThread::CurrentId());
-  }
-
-  delete thread_params;
-  delegate->ThreadMain();
-
-  if (did_dup) {
-    ThreadIdNameManager::GetInstance()->RemoveName(
-        scoped_platform_handle.Get(),
-        PlatformThread::CurrentId());
-  }
-
-  return NULL;
-}
-
-// CreateThreadInternal() matches PlatformThread::Create(), except that
-// |out_thread_handle| may be NULL, in which case a non-joinable thread is
-// created.
-bool CreateThreadInternal(size_t stack_size,
-                          PlatformThread::Delegate* delegate,
-                          PlatformThreadHandle* out_thread_handle) {
-  unsigned int flags = 0;
-  if (stack_size > 0 && base::win::GetVersion() >= base::win::VERSION_XP) {
-    flags = STACK_SIZE_PARAM_IS_A_RESERVATION;
-  } else {
-    stack_size = 0;
-  }
-
-  ThreadParams* params = new ThreadParams;
-  params->delegate = delegate;
-  params->joinable = out_thread_handle != NULL;
-
-  // Using CreateThread here vs _beginthreadex makes thread creation a bit
-  // faster and doesn't require the loader lock to be available.  Our code will
-  // have to work running on CreateThread() threads anyway, since we run code
-  // on the Windows thread pool, etc.  For some background on the difference:
-  //   http://www.microsoft.com/msj/1099/win32/win321099.aspx
-  void* thread_handle = CreateThread(
-      NULL, stack_size, ThreadFunc, params, flags, NULL);
-  if (!thread_handle) {
-    delete params;
-    return false;
-  }
-
-  if (out_thread_handle)
-    *out_thread_handle = PlatformThreadHandle(thread_handle);
-  else
-    CloseHandle(thread_handle);
-  return true;
-}
-
-}  // namespace
-
-// static
-PlatformThreadId PlatformThread::CurrentId() {
-  return GetCurrentThreadId();
-}
-
-// static
-PlatformThreadRef PlatformThread::CurrentRef() {
-  return PlatformThreadRef(GetCurrentThreadId());
-}
-
-// static
-PlatformThreadHandle PlatformThread::CurrentHandle() {
-  NOTIMPLEMENTED(); // See OpenThread()
-  return PlatformThreadHandle();
-}
-
 // static
 void PlatformThread::YieldCurrentThread() {
   ::Sleep(0);
 }
 
-// static
-void PlatformThread::Sleep(TimeDelta duration) {
-  // When measured with a high resolution clock, Sleep() sometimes returns much
-  // too early. We may need to call it repeatedly to get the desired duration.
-  TimeTicks end = TimeTicks::Now() + duration;
-  for (TimeTicks now = TimeTicks::Now(); now < end; now = TimeTicks::Now())
-    ::Sleep(static_cast<DWORD>((end - now).InMillisecondsRoundedUp()));
-}
-
-// static
-void PlatformThread::SetName(const char* name) {
-  ThreadIdNameManager::GetInstance()->SetName(CurrentId(), name);
-
-  // On Windows only, we don't need to tell the profiler about the "BrokerEvent"
-  // thread, as it exists only in the chrome.exe image, and never spawns or runs
-  // tasks (items which could be profiled).  This test avoids the notification,
-  // which would also (as a side effect) initialize the profiler in this unused
-  // context, including setting up thread local storage, etc.  The performance
-  // impact is not terrible, but there is no reason to do initialize it.
-  if (0 != strcmp(name, "BrokerEvent"))
-    tracked_objects::ThreadData::InitializeThreadContext(name);
-
-  // The debugger needs to be around to catch the name in the exception.  If
-  // there isn't a debugger, we are just needlessly throwing an exception.
-  // If this image file is instrumented, we raise the exception anyway
-  // to provide the profiler with human-readable thread names.
-  if (!::IsDebuggerPresent() && !base::debug::IsBinaryInstrumented())
-    return;
-
-  SetNameInternal(CurrentId(), name);
-}
-
-// static
-const char* PlatformThread::GetName() {
-  return ThreadIdNameManager::GetInstance()->GetName(CurrentId());
-}
-
-// static
-bool PlatformThread::Create(size_t stack_size, Delegate* delegate,
-                            PlatformThreadHandle* thread_handle) {
-  DCHECK(thread_handle);
-  return CreateThreadInternal(stack_size, delegate, thread_handle);
-}
-
-// static
-bool PlatformThread::CreateWithPriority(size_t stack_size, Delegate* delegate,
-                                        PlatformThreadHandle* thread_handle,
-                                        ThreadPriority priority) {
-  bool result = Create(stack_size, delegate, thread_handle);
-  if (result)
-    SetThreadPriority(*thread_handle, priority);
-  return result;
-}
-
-// static
-bool PlatformThread::CreateNonJoinable(size_t stack_size, Delegate* delegate) {
-  return CreateThreadInternal(stack_size, delegate, NULL);
-}
-
-// static
-void PlatformThread::Join(PlatformThreadHandle thread_handle) {
-  DCHECK(thread_handle.handle_);
-  // TODO(willchan): Enable this check once I can get it to work for Windows
-  // shutdown.
-  // Joining another thread may block the current thread for a long time, since
-  // the thread referred to by |thread_handle| may still be running long-lived /
-  // blocking tasks.
-#if 0
-  base::ThreadRestrictions::AssertIOAllowed();
-#endif
-
-  // Wait for the thread to exit.  It should already have terminated but make
-  // sure this assumption is valid.
-  DWORD result = WaitForSingleObject(thread_handle.handle_, INFINITE);
-  if (result != WAIT_OBJECT_0) {
-    // Debug info for bug 127931.
-    DWORD error = GetLastError();
-    debug::Alias(&error);
-    debug::Alias(&result);
-    debug::Alias(&thread_handle.handle_);
-    CHECK(false);
-  }
-
-  CloseHandle(thread_handle.handle_);
-}
-
-// static
-void PlatformThread::SetThreadPriority(PlatformThreadHandle handle,
-                                       ThreadPriority priority) {
-  switch (priority) {
-    case kThreadPriority_Normal:
-      ::SetThreadPriority(handle.handle_, THREAD_PRIORITY_NORMAL);
-      break;
-    case kThreadPriority_RealtimeAudio:
-      ::SetThreadPriority(handle.handle_, THREAD_PRIORITY_TIME_CRITICAL);
-      break;
-    default:
-      NOTREACHED() << "Unknown priority.";
-      break;
-  }
-}
-
 }  // namespace base
-- 
1.8.4.msysgit.0

